
//-------------------------------------------------<                   axlib v1.1                    >----------------------------------------------------
//-------------------------------------------------<        Библиотека для работы с шиной I2C        >----------------------------------------------------
//-------------------------------------------------<    Кузнецов Алексей 2015 http://www.avrki.ru    >----------------------------------------------------

#ifndef I2C_H_
#define I2C_H_

//-------------------------------------------------------------------------
//						Объявление служебных псевдонимов
//-------------------------------------------------------------------------

#define ACK  0		// Ответ удачный
#define NACK 1		// Ответ не удачный

#define I2C_DELAY()	_delay_us(10);	// Общая пауза на шине

#define ONE_SCL()	{ I2C_DDR &= ~(1 << SCL); I2C_PORT |= (1 << SCL); }  // Установка единицы на линии SCL
#define NULL_SCL()	{ I2C_DDR |= (1 << SCL);  I2C_PORT &= ~(1 << SCL); } // Установка нуля на линии SCL
#define ONE_SDA()	{ I2C_DDR &= ~(1 << SDA); I2C_PORT |= (1 << SDA); }  // Установка единицы на линии SDA
#define NULL_SDA()	{ I2C_DDR |= (1 << SDA);  I2C_PORT &= ~(1 << SDA); } // Установка нуля на линии SDA

#define OK				0	// Линия в норме
#define SCL_FAIL		1	// Ошибка линии SCL
#define SDA_FAIL		2	// Ошибка линии SDA

//-------------------------------------------------------------------------
//							Объявление функций
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//	Функция условия СТОП.
//
//	Возвращает OK
//
//-------------------------------------------------------------------------

uint8_t i2c_stop(void)
{
	uint8_t error = OK;
	
	NULL_SCL();
	I2C_DELAY();
	NULL_SDA();
	I2C_DELAY();
	
	ONE_SCL();
	I2C_DELAY();
	ONE_SDA();
	I2C_DELAY();
	
	if((I2C_PIN & (1 << SDA)) == 0) error = SDA_FAIL;
	if((I2C_PIN & (1 << SCL)) == 0) error += SCL_FAIL;
	I2C_DELAY();
	I2C_DELAY();
	I2C_DELAY();
	I2C_DELAY();
	
	return error;
}

//-------------------------------------------------------------------------
//	Функция условия СТАРТ.
//
//-------------------------------------------------------------------------

void i2c_start(void)
{
	NULL_SDA();
	I2C_DELAY();
	NULL_SCL();
	I2C_DELAY();
}

//-------------------------------------------------------------------------
//	Функция передачи байта в шину.
//
//	Принимамые аргументы:
//
//		uint8_t data - байт для передачи в шину
//
//  Возвращаемое значение:
//
//		Ответ от ведомого устройства ACK принято, NACK ошибка.
//-------------------------------------------------------------------------

uint8_t i2c_send_byte(uint8_t data)
{
	uint8_t i;
	uint8_t ask = ACK;
	
	for(i = 0; i < 8; i++)
	{
		if((data & 0x80) == 0)
		{
			NULL_SDA();
		}
		else
		{
			ONE_SDA();
		}
		I2C_DELAY();
		ONE_SCL();
		I2C_DELAY();
		NULL_SCL();
		
		data = (data << 1);
	}
	
	ONE_SDA();
	I2C_DELAY();
	ONE_SCL();
	I2C_DELAY();
	
	if((I2C_PIN & (1 << SDA)) == (1 << SDA))
	{
		ask = NACK;
	}
	else
	{
		ask = ACK;
	}
	
	NULL_SCL();
	
	return ask;
}

//-------------------------------------------------------------------------
//	Функция передачи байта микросхеме для вывода.
//
//	Принимает аргументы:
//
//		uint8_t data - Байт который необходимо отправить микросхеме.
//		uint8_t add - Адрес микросхемы
//
//	Возвращает ACK при удаче и NACK при неудаче
//-------------------------------------------------------------------------

uint8_t pcf8574_byte_out(uint8_t data, uint8_t add)
{
	uint8_t ask = ACK;
	add &= 0xFE;
	
	i2c_start();
	ask = i2c_send_byte(add);
	if(!ask) ask = i2c_send_byte(data);
	i2c_stop();
	
	return ask;
}

//////////////////////////////////////////////////////////////////////////

void com(uint8_t com)
{
	com |= 0x04;				// Е в единицу
	pcf8574_byte_out(com, ADD);	// Вывод данных
	com &= 0xFB;				// Е в ноль
	pcf8574_byte_out(com, ADD);	// Вывод данных
}

void clear_i2c(void)
{
	com(0x00);		// Очищаем дисплей
	com(0x10);		// Очищаем дисплей
}

void init_i2c(void)
{
	_delay_ms(20);	// Wait for 15ms, Power-on initialization time for LCD16x2.
	
	com(0x00);		// Переход в 4-х битный режим
	com(0x20);		// Переход в 4-х битный режим
	
	com(0x20);		// Установка параметров
	com(0x80);		// Установка параметров
	
	com(0x00);		// Выключаем дисплей
	com(0x80);		// Выключаем дисплей
	
	com(0x00);		// Очищаем дисплей
	com(0x10);		// Очищаем дисплей
	
	com(0x00);		// Устанавливаем режим ввода данных
	com(0x60);		// Устанавливаем режим ввода данных
	
	com(0x00);		// Включаем дисплей с выбранным курсором
	com(0xE0);		// Включаем дисплей с выбранным курсором
}

void char_out(const uint8_t data)
{
	uint8_t data_h = ((data & 0xF0) + 0x09);
	uint8_t data_l = ((data << 4) + 0x09);
	
	pcf8574_byte_out(data_h, ADD); // Передача старших 4 бит
	data_h |= 0x04;
	pcf8574_byte_out(data_h, ADD); // Передача старших 4 бит
	data_h &= 0xF9;
	pcf8574_byte_out(data_h, ADD); // Передача старших 4 бит
	
	pcf8574_byte_out(data_l, ADD); // Передача младших 4 бит
	data_l |= 0x04;
	pcf8574_byte_out(data_l, ADD); // Передача младших 4 бит
	data_l &= 0xF9;
	pcf8574_byte_out(data_l, ADD); // Передача младших 4 бит
}

void str_out(const uint8_t *str, const uint8_t len)
{
	clear_i2c();
 	if (len == NULL)
	{
		while((*str) != '\0')
		{
			char_out(*str);
			str++;
		}
	}
	else
	{
		for (int8_t i = 0; i < len; i++)
		{
			char_out(*str);
			str++;
		}
	}
}

#endif /* I2C_H_ */